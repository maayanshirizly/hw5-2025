import json
import pathlib
from typing import Union, Tuple
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Disable GUI backend
import matplotlib.pyplot as plt

__all__ = ["QuestionnaireAnalysis", "np", "pd"]



class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        if not isinstance(data_fname, (str, pathlib.Path)):
            raise TypeError("data_fname must be a string or pathlib.Path")
        self.data_fname = pathlib.Path(data_fname)
        if not self.data_fname.exists():
            raise ValueError("The file does not exist")
        self.data = None

    def read_data(self):
        """Reads the json data located in self.data_fname into memory."""
        with open(self.data_fname, 'r', encoding='utf-8') as f:
            raw = json.load(f)
        self.data = pd.DataFrame(raw)

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        ages = pd.to_numeric(self.data['age'], errors='coerce')  # ממיר ל־float, שגיאות הופכות ל־NaN
        bins = np.arange(0, 110, 10)
        hist, edges = np.histogram(ages, bins=bins)
        plt.bar(edges[:-1], hist, width=10, edgecolor='black', align='edge')
        plt.xlabel('Age')
        plt.ylabel('Number of Participants')
        plt.title('Age Distribution')
        plt.show()
        return hist, edges

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Removes rows with invalid emails and returns cleaned DataFrame."""
        def is_valid_email(email):
            if not isinstance(email, str):
                return False
            if email.count('@') != 1:
                return False
            if email.startswith('@') or email.endswith('@'):
                return False
            if '.' not in email or email.startswith('.') or email.endswith('.'):
                return False
            local_part, domain = email.split('@')
            if domain.startswith('.'):
                return False
            return True

        valid_mask = self.data['email'].apply(is_valid_email)
        df = self.data[valid_mask].reset_index(drop=True)
        return df

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Fills missing grades with the average of other grades per student."""
        df = self.data.copy()
        question_cols = [col for col in df.columns if col.startswith('q')]
        affected_indices = []
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')

        for idx, row in df.iterrows():
            missing = row[question_cols].isnull()
            if missing.any():
                mean = row[question_cols].mean(skipna=True)
                if not np.isnan(mean):
                    df.loc[idx, question_cols] = row[question_cols].fillna(mean).infer_objects()
                    affected_indices.append(idx)
                    

        return df, np.array(affected_indices)

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates average score and adds it as 'score' column."""
        df = self.data.copy()
        question_cols = [col for col in df.columns if col.startswith('q')]
        
        # 👇 הוספה חשובה: להמיר למספרים ולסלק מחרוזות כמו "nan"
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')

        def calculate_score(row):
            num_nans = row[question_cols].isnull().sum()
            if num_nans > maximal_nans_per_sub:
                return pd.NA
            score = np.floor(row[question_cols].mean(skipna=True))
            return int(score) if not np.isnan(score) else pd.NA

        df['score'] = df.apply(calculate_score, axis=1)
        #df = df.dropna(subset=['score'])  # מסיר שורות עם NA בציון
        #df['score'] = df['score'].astype('Int64').astype(pd.UInt8Dtype())

        # ✅ תשאירי את כל השורות, גם אם יש להן NA
        df['score'] = df['score'].astype('Int64').astype(pd.UInt8Dtype(), errors='ignore')

        return df


    def correlate_gender_age(self) -> pd.DataFrame:
        """Groups by gender and age group (above/below 40), and computes question means."""
        #self.data, _ = self.fill_na_with_mean()
        df = self.data.copy()
        #df, _ = self.fill_na_with_mean()  # ✅ שימוש נכון במילוי פר־שורה

        question_cols = [col for col in df.columns if col.startswith('q')]
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')
        
        # ✅ במקום fill_na_with_mean → מילוי לפי ממוצע כל עמודה
        #df[question_cols] = df[question_cols].fillna(df[question_cols].mean())
        
        # 💡 מילוי NA לפי ממוצע עמודה גלובלי (לא לפי קבוצה!)
        #df[question_cols] = df[question_cols].fillna(self.data[question_cols].mean())
        
        # המרה של עמודת גיל למספר    
        df['age'] = pd.to_numeric(df['age'], errors='coerce')
        
        # סינון שורות לא חוקיות (למשל מגדר חסר או גיל חסר)
        df = df[df['gender'].notna() & df['age'].notna()]

        # מילוי ערכים חסרים לפי ממוצע כל עמודת שאלה (מבין הנתונים התקפים)
        #col_means = df[question_cols].mean(numeric_only=True)
        #df[question_cols] = df[question_cols].fillna(col_means)
        #df[question_cols] = df[question_cols].fillna(df[question_cols].mean())

        df['age'] = df['age'] > 40  # True/False
        #df['age'] = df['age'].apply(lambda x: 'above_40' if x > 40 else 'under_40')
        
        # 🧠 שלב חדש: מילוי NA לפי ממוצע כל עמודת שאלה בקבוצה
        df[question_cols] = df.groupby(['gender', 'age'])[question_cols].transform(lambda x: x.fillna(x.mean()))

        grouped = df.groupby(['gender', 'age'])[question_cols].mean()
        #return grouped
        return grouped.sort_index()



