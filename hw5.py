import json
import pathlib
from typing import Union, Tuple
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Disable GUI backend
import matplotlib.pyplot as plt

__all__ = ["QuestionnaireAnalysis", "np", "pd"]



class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        if not isinstance(data_fname, (str, pathlib.Path)):
            raise TypeError("data_fname must be a string or pathlib.Path")
        self.data_fname = pathlib.Path(data_fname)
        if not self.data_fname.exists():
            raise ValueError("The file does not exist")
        self.data = None

    def read_data(self):
        """Reads the json data located in self.data_fname into memory."""
        with open(self.data_fname, 'r', encoding='utf-8') as f:
            raw = json.load(f)
        self.data = pd.DataFrame(raw)

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        ages = pd.to_numeric(self.data['age'], errors='coerce')  # ×××™×¨ ×œÖ¾float, ×©×’×™××•×ª ×”×•×¤×›×•×ª ×œÖ¾NaN
        bins = np.arange(0, 110, 10)
        hist, edges = np.histogram(ages, bins=bins)
        plt.bar(edges[:-1], hist, width=10, edgecolor='black', align='edge')
        plt.xlabel('Age')
        plt.ylabel('Number of Participants')
        plt.title('Age Distribution')
        plt.show()
        return hist, edges

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Removes rows with invalid emails and returns cleaned DataFrame."""
        def is_valid_email(email):
            if not isinstance(email, str):
                return False
            if email.count('@') != 1:
                return False
            if email.startswith('@') or email.endswith('@'):
                return False
            if '.' not in email or email.startswith('.') or email.endswith('.'):
                return False
            local_part, domain = email.split('@')
            if domain.startswith('.'):
                return False
            return True

        valid_mask = self.data['email'].apply(is_valid_email)
        df = self.data[valid_mask].reset_index(drop=True)
        return df

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Fills missing grades with the average of other grades per student."""
        df = self.data.copy()
        question_cols = [col for col in df.columns if col.startswith('q')]
        affected_indices = []
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')

        for idx, row in df.iterrows():
            missing = row[question_cols].isnull()
            if missing.any():
                mean = row[question_cols].mean(skipna=True)
                if not np.isnan(mean):
                    df.loc[idx, question_cols] = row[question_cols].fillna(mean).infer_objects()
                    affected_indices.append(idx)
                    

        return df, np.array(affected_indices)

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates average score and adds it as 'score' column."""
        df = self.data.copy()
        question_cols = [col for col in df.columns if col.startswith('q')]
        
        # ğŸ‘‡ ×”×•×¡×¤×” ×—×©×•×‘×”: ×œ×”××™×¨ ×œ××¡×¤×¨×™× ×•×œ×¡×œ×§ ××—×¨×•×–×•×ª ×›××• "nan"
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')

        def calculate_score(row):
            num_nans = row[question_cols].isnull().sum()
            if num_nans > maximal_nans_per_sub:
                return pd.NA
            score = np.floor(row[question_cols].mean(skipna=True))
            return int(score) if not np.isnan(score) else pd.NA

        df['score'] = df.apply(calculate_score, axis=1)
        #df = df.dropna(subset=['score'])  # ××¡×™×¨ ×©×•×¨×•×ª ×¢× NA ×‘×¦×™×•×Ÿ
        #df['score'] = df['score'].astype('Int64').astype(pd.UInt8Dtype())

        # âœ… ×ª×©××™×¨×™ ××ª ×›×œ ×”×©×•×¨×•×ª, ×’× ×× ×™×© ×œ×”×Ÿ NA
        df['score'] = df['score'].astype('Int64').astype(pd.UInt8Dtype(), errors='ignore')

        return df


    def correlate_gender_age(self) -> pd.DataFrame:
        """Groups by gender and age group (above/below 40), and computes question means."""
        #self.data, _ = self.fill_na_with_mean()
        df = self.data.copy()
        #df, _ = self.fill_na_with_mean()  # âœ… ×©×™××•×© × ×›×•×Ÿ ×‘××™×œ×•×™ ×¤×¨Ö¾×©×•×¨×”

        question_cols = [col for col in df.columns if col.startswith('q')]
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')
        
        # âœ… ×‘××§×•× fill_na_with_mean â†’ ××™×œ×•×™ ×œ×¤×™ ×××•×¦×¢ ×›×œ ×¢××•×“×”
        #df[question_cols] = df[question_cols].fillna(df[question_cols].mean())
        
        # ğŸ’¡ ××™×œ×•×™ NA ×œ×¤×™ ×××•×¦×¢ ×¢××•×“×” ×’×œ×•×‘×œ×™ (×œ× ×œ×¤×™ ×§×‘×•×¦×”!)
        #df[question_cols] = df[question_cols].fillna(self.data[question_cols].mean())
        
        # ×”××¨×” ×©×œ ×¢××•×“×ª ×’×™×œ ×œ××¡×¤×¨    
        df['age'] = pd.to_numeric(df['age'], errors='coerce')
        
        # ×¡×™× ×•×Ÿ ×©×•×¨×•×ª ×œ× ×—×•×§×™×•×ª (×œ××©×œ ××’×“×¨ ×—×¡×¨ ××• ×’×™×œ ×—×¡×¨)
        df = df[df['gender'].notna() & df['age'].notna()]

        # ××™×œ×•×™ ×¢×¨×›×™× ×—×¡×¨×™× ×œ×¤×™ ×××•×¦×¢ ×›×œ ×¢××•×“×ª ×©××œ×” (××‘×™×Ÿ ×”× ×ª×•× ×™× ×”×ª×§×¤×™×)
        #col_means = df[question_cols].mean(numeric_only=True)
        #df[question_cols] = df[question_cols].fillna(col_means)
        #df[question_cols] = df[question_cols].fillna(df[question_cols].mean())

        df['age'] = df['age'] > 40  # True/False
        #df['age'] = df['age'].apply(lambda x: 'above_40' if x > 40 else 'under_40')
        
        # ğŸ§  ×©×œ×‘ ×—×“×©: ××™×œ×•×™ NA ×œ×¤×™ ×××•×¦×¢ ×›×œ ×¢××•×“×ª ×©××œ×” ×‘×§×‘×•×¦×”
        df[question_cols] = df.groupby(['gender', 'age'])[question_cols].transform(lambda x: x.fillna(x.mean()))

        grouped = df.groupby(['gender', 'age'])[question_cols].mean()
        #return grouped
        return grouped.sort_index()



